<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Wordiness — Morpheme LEGO</title>
<style>
  :root{
    --bg:#070b16; --panel:rgba(255,255,255,.06); --line:rgba(255,255,255,.14);
    --text:#eef2ff; --muted:rgba(238,242,255,.70);
    --acc:#38bdf8; --ok:#22c55e; --bad:#ef4444; --warn:#f59e0b;
    --r:18px; --fs:18px; --lh:1.65; --ls:0px; --ws:0px;
  }
  body.supported{ --fs:19px; --lh:1.9; --ls:.2px; --ws:.7px; }
  body{ margin:0; color:var(--text); background:radial-gradient(900px 500px at 15% -10%, rgba(56,189,248,.14), transparent 60%),
                           radial-gradient(900px 500px at 92% 10%, rgba(34,197,94,.12), transparent 55%),
                           linear-gradient(180deg,#050816,var(--bg));
        font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;
        font-size:var(--fs); line-height:var(--lh); letter-spacing:var(--ls); word-spacing:var(--ws); }
  .wrap{ max-width:1100px; margin:0 auto; padding:16px; }
  header{ position:sticky; top:10px; z-index:5; backdrop-filter: blur(10px);
          border:1px solid var(--line); border-radius:var(--r); padding:12px 14px;
          background:linear-gradient(180deg, rgba(20,30,55,.85), rgba(10,18,38,.78));
          display:flex; gap:12px; flex-wrap:wrap; justify-content:space-between; align-items:center; }
  h1{ margin:0; font-size:18px; }
  .sub{ color:var(--muted); font-size:13px; margin-top:3px; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  select,button{ font:inherit; }
  select{ background:rgba(0,0,0,.25); color:var(--text); border:1px solid var(--line);
          padding:8px 10px; border-radius:12px; }
  button{ cursor:pointer; color:var(--text); border:1px solid rgba(56,189,248,.32);
          background:linear-gradient(180deg, rgba(56,189,248,.14), rgba(56,189,248,.06));
          padding:10px 12px; border-radius:12px; }
  button.ghost{ border:1px solid var(--line); background:rgba(255,255,255,.04); }
  button.good{ border:1px solid rgba(34,197,94,.55);
               background:linear-gradient(180deg, rgba(34,197,94,.22), rgba(34,197,94,.10)); }
  button:disabled{ opacity:.55; cursor:not-allowed; }
  .card{ margin-top:14px; border:1px solid var(--line); border-radius:var(--r);
         background:linear-gradient(180deg, rgba(16,27,51,.78), rgba(11,20,40,.72)); overflow:hidden; }
  .hd{ padding:12px 14px; border-bottom:1px solid var(--line); display:flex; gap:10px; flex-wrap:wrap;
       justify-content:space-between; align-items:flex-start; }
  .bd{ padding:14px; }
  .big{ margin:0; font-size:26px; font-weight:950; }
  .hint{ margin:8px 0 0; color:var(--muted); font-size:13px; }
  .pill{ display:inline-flex; align-items:center; gap:8px; font-size:13px; color:rgba(238,242,255,.88);
         padding:8px 10px; border-radius:999px; border:1px solid var(--line); background:rgba(255,255,255,.05); }
  .grid{ display:grid; grid-template-columns: 1.2fr .8fr; gap:14px; }
  @media(max-width:980px){ .grid{ grid-template-columns:1fr; } }
  .note{ border:1px solid var(--line); background:rgba(0,0,0,.10); border-radius:14px; padding:10px 12px; font-size:13px; color:rgba(238,242,255,.88); }
  body.supported .note{ font-size:14px; }

  .board{ margin-top:12px; border:1px solid var(--line); border-radius:16px; padding:12px; background:rgba(0,0,0,.10); }
  .slots{ display:grid; grid-template-columns:1fr 1fr 1fr; gap:10px; margin-top:10px; }
  @media(max-width:720px){ .slots{ grid-template-columns:1fr; } }
  .slot{ border:1px dashed rgba(255,255,255,.22); border-radius:16px; padding:10px; background:rgba(255,255,255,.03); min-height:78px;
         display:flex; flex-direction:column; gap:8px; }
  .slotTitle{ display:flex; justify-content:space-between; align-items:center; font-size:13px; font-weight:950; color:rgba(238,242,255,.86); }
  .mini{ font-weight:700; color:rgba(238,242,255,.62); }
  .drop{ flex:1; display:flex; justify-content:center; align-items:center; text-align:center;
         border-radius:14px; border:1px solid rgba(255,255,255,.14); background:rgba(255,255,255,.04); padding:10px; }
  .chip{ display:inline-flex; gap:8px; align-items:center; padding:10px 12px; border-radius:999px;
         border:1px solid rgba(56,189,248,.40); background:rgba(56,189,248,.10); font-weight:950; }
  .chip .m{ display:none; font-weight:700; font-size:12px; color:rgba(238,242,255,.72); }
  body.supported .chip .m{ display:inline; }
  .built{ margin-top:12px; border:1px solid var(--line); border-radius:16px; padding:12px; background:rgba(0,0,0,.10); }
  .word{ margin:0; font-size:34px; font-weight:1000; word-break:break-word; }
  .line{ margin-top:6px; font-size:13px; color:rgba(238,242,255,.78); }

  .pal{ margin-top:12px; display:grid; grid-template-columns:1fr 1fr; gap:12px; }
  @media(max-width:720px){ .pal{ grid-template-columns:1fr; } }
  .bucket{ border:1px solid var(--line); border-radius:16px; padding:12px; background:rgba(0,0,0,.10); }
  .bucketTitle{ display:flex; justify-content:space-between; align-items:baseline; font-weight:950; color:rgba(238,242,255,.88); }
  .bucketTitle span{ font-weight:700; color:rgba(238,242,255,.62); font-size:12px; }
  .pieces{ display:flex; flex-wrap:wrap; gap:10px; margin-top:10px; }
  .piece{ border:1px solid rgba(255,255,255,.16); background:rgba(255,255,255,.04); color:rgba(238,242,255,.92);
          border-radius:999px; padding:10px 12px; font-weight:950; cursor:pointer; user-select:none; }
  .piece.sel{ border-color:rgba(56,189,248,.75); background:rgba(56,189,248,.12); }
  .piece .m{ display:none; }
  body.supported .piece .m{ display:inline; font-weight:700; margin-left:8px; color:rgba(238,242,255,.72); }

  .status{ margin-top:12px; border:1px solid var(--line); border-radius:14px; padding:10px 12px; background:rgba(255,255,255,.03);
           font-size:13px; color:rgba(238,242,255,.88); display:flex; gap:10px; flex-wrap:wrap; justify-content:space-between; }
  .ok{ color:var(--ok); font-weight:950; }
  .bad{ color:var(--bad); font-weight:950; }
  .warn{ color:var(--warn); font-weight:950; }
  details{ margin-top:12px; border:1px solid var(--line); border-radius:14px; padding:10px 12px; background:rgba(0,0,0,.10); }
  summary{ cursor:pointer; font-weight:950; list-style:none; }
  summary::-webkit-details-marker{ display:none; }
  table{ width:100%; border-collapse:collapse; font-size:13px; }
  th,td{ border-bottom:1px solid rgba(255,255,255,.10); padding:8px 6px; text-align:left; vertical-align:top; }
  th{ font-weight:950; }
</style>
<style>
/* wordiness-ui-polish-v4 */
:root{
  --tapMin: 44px;
  --safeBottom: env(safe-area-inset-bottom, 0px);
}
html, body{ height: 100%; }
body{
  min-height: 100dvh;
  padding-bottom: var(--safeBottom);
  -webkit-text-size-adjust: 100%;
  overscroll-behavior: contain;
}
@supports (height: 100svh){ body{ min-height: 100svh; } }

*{ -webkit-tap-highlight-color: transparent; }

button, [role="button"], a, input, select, textarea,
.tile, .wordCard, .slot, .badge{
  min-height: var(--tapMin);
}

button, [role="button"], a, .tile, .wordCard, .slot{
  touch-action: manipulation;
  user-select: none;
  -webkit-user-select: none;
}

input, textarea, select{
  font-size: 16px !important; /* prevent iOS zoom */
}

[draggable="true"], .wordiness-draggable{
  touch-action: none; /* reduce scroll-vs-drag fighting */
}

.wordiness-drag-selected{
  outline: 3px solid rgba(56,189,248,.55) !important;
}

@media (prefers-reduced-motion: reduce){
  *{ scroll-behavior: auto !important; transition: none !important; animation: none !important; }
}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Wordiness — Morpheme LEGO</h1>
      <div class="sub">Snap <b>prefix</b> + <b>base</b> + <b>suffix</b>. Supported adds cues, but the answer key stays the same.</div>
    </div>
    <div class="row">
      <label class="row" style="gap:6px;color:var(--muted);font-size:13px">Mode
        <select id="mode">
          <option value="challenge">Challenge</option>
          <option value="free">Free build</option>
        </select>
      </label>
      <label class="row" style="gap:6px;color:var(--muted);font-size:13px">View
        <select id="variant">
          <option value="standard">Standard</option>
          <option value="supported">Supported</option>
        </select>
      </label>
      <label class="row" style="gap:6px;color:var(--muted);font-size:13px">Voice
        <select id="voice"></select>
      </label>
      <button class="ghost" id="nextTop">Next</button>
    </div>
  </header>

  <section class="card">
    <div class="hd">
      <div>
        <div class="sub">Now building</div>
        <p class="big" id="titleBig">—</p>
        <p class="hint" id="taskHint"></p>
      </div>
      <div class="row">
        <span class="pill">Score <b id="score">0</b>/<b id="total">0</b></span>
        <button class="ghost" id="speakWord">Speak</button>
        <button class="ghost" id="speakChunks">Speak chunks</button>
        <button class="ghost" id="showAnswer">Show answer</button>
        <button class="ghost" id="clear">Clear</button>
        <button class="good" id="check">Check</button>
      </div>
    </div>

    <div class="bd">
      <div class="grid">
        <div>
          <div class="note" id="supportNote" style="display:none"></div>

          <div class="board">
            <div class="sub">Assembly board</div>
            <div class="hint" style="margin-top:6px">Tap a piece to select it, then tap a slot to place it.</div>

            <div class="slots">
              <div class="slot">
                <div class="slotTitle">Prefix <span class="mini">(optional)</span></div>
                <div class="drop" id="slotPrefix">Tap to place</div>
              </div>
              <div class="slot">
                <div class="slotTitle">Base word <span class="mini">(fixed in challenge)</span></div>
                <div class="drop" id="slotBase">—</div>
              </div>
              <div class="slot">
                <div class="slotTitle">Suffix <span class="mini">(optional)</span></div>
                <div class="drop" id="slotSuffix">Tap to place</div>
              </div>
            </div>

            <div class="built">
              <div class="sub">Built word</div>
              <p class="word" id="builtWord">—</p>
              <div class="line" id="builtLine"></div>
            </div>
          </div>

          <div class="pal">
            <div class="bucket">
              <div class="bucketTitle">Prefixes <span>tap</span></div>
              <div class="pieces" id="prefixPieces"></div>
            </div>
            <div class="bucket">
              <div class="bucketTitle">Suffixes <span>tap</span></div>
              <div class="pieces" id="suffixPieces"></div>
            </div>
          </div>

          <div class="status">
            <span>Status: <b id="status">ready</b></span>
            <span class="hint">Tip: In Supported, pieces show meanings (“again”, “not”, “person who…”).</span>
          </div>
        </div>

        <aside>
          <div class="note">
            <b>Why dyslexia/neurodivergent-friendly?</b><br>
            Morphology makes reading feel less like guessing and more like “LEGO logic”.
            Structure reduces working-memory load, and TTS gives fast feedback without shame-spirals.
          </div>

          <details open>
            <summary>Teacher Key (same for both views)</summary>
            <div class="hint" style="margin-top:10px" id="key"></div>
          </details>

          <details>
            <summary>Customize</summary>
            <div class="hint" style="margin-top:10px">
              Edit <code>CHALLENGES</code> and <code>PIECES</code> inside this file.
            </div>
          </details>
        </aside>
      </div>
    </div>
  </section>
</div>

<script>
const PIECES = {
  prefixes: [
    { id:"none", text:"", show:"(none)", meaning:"" },
    { id:"un",   text:"un",  show:"un-", meaning:"not / opposite" },
    { id:"re",   text:"re",  show:"re-", meaning:"again" },
    { id:"pre",  text:"pre", show:"pre-", meaning:"before" },
    { id:"mis",  text:"mis", show:"mis-", meaning:"wrongly" },
    { id:"dis",  text:"dis", show:"dis-", meaning:"not / opposite" }
  ],
  suffixes: [
    { id:"none", text:"", show:"(none)", meaning:"" },
    { id:"er",   text:"er",   show:"-er",   meaning:"person who…" },
    { id:"ful",  text:"ful",  show:"-ful",  meaning:"full of" },
    { id:"less", text:"less", show:"-less", meaning:"without" },
    { id:"ly",   text:"ly",   show:"-ly",   meaning:"in that way" },
    { id:"ness", text:"ness", show:"-ness", meaning:"state / quality" }
  ]
};

// SAME answer key for Standard + Supported.
// Keep spellings “clean” (no tricky dropping-e rules) unless you want to teach them explicitly.
const CHALLENGES = [
  { base:"happy", prefix:"un",   suffix:"none", target:"unhappy",  prompt:"Make the opposite of happy.", gloss:"not happy" },
  { base:"kind",  prefix:"none", suffix:"ness", target:"kindness", prompt:"Make a noun meaning “the quality of being kind.”", gloss:"quality of being kind" },
  { base:"help",  prefix:"none", suffix:"ful",  target:"helpful",  prompt:"Make an adjective meaning “full of help.”", gloss:"willing/able to help" },
  { base:"care",  prefix:"none", suffix:"less", target:"careless", prompt:"Make an adjective meaning “without care.”", gloss:"not careful" },
  { base:"quick", prefix:"none", suffix:"ly",   target:"quickly",  prompt:"Make an adverb meaning “in a quick way.”", gloss:"fast" },
  { base:"do",    prefix:"re",   suffix:"none", target:"redo",     prompt:"Make a verb meaning “do again.”", gloss:"do again" },
  { base:"play",  prefix:"none", suffix:"er",   target:"player",   prompt:"Make a noun meaning “a person who plays.”", gloss:"person who plays" },
  { base:"agree", prefix:"dis",  suffix:"none", target:"disagree", prompt:"Make the opposite of agree.", gloss:"not agree" },
  { base:"view",  prefix:"pre",  suffix:"none", target:"preview",  prompt:"Make a verb meaning “view before.”", gloss:"look before" }
];

const $ = (s, r=document)=>r.querySelector(s);
const esc = (s)=>String(s??"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#039;");

let voices=[];
function refreshVoices(){
  if(!window.speechSynthesis) return;
  voices = speechSynthesis.getVoices()||[];
  const sel=$("#voice"); sel.innerHTML="";
  const d=document.createElement("option"); d.value=""; d.textContent=voices.length?"Default":"No voices"; sel.appendChild(d);
  voices.forEach((v,i)=>{ const o=document.createElement("option"); o.value=String(i); o.textContent=`${v.name} (${v.lang})`; sel.appendChild(o); });
}
function speak(text, rate=1.0){
  if(!window.speechSynthesis) return;
  const u=new SpeechSynthesisUtterance(String(text||""));
  const idx=parseInt($("#voice").value,10);
  if(Number.isFinite(idx) && voices[idx]) u.voice=voices[idx];
  u.rate=Math.max(0.7, Math.min(1.1, rate));
  speechSynthesis.cancel(); speechSynthesis.speak(u);
}
async function speakChunks(chunks){
  if(!window.speechSynthesis) return;
  const rate = state.variant==="supported" ? 0.86 : 0.95;
  speechSynthesis.cancel();
  for(const ch of chunks){
    const u=new SpeechSynthesisUtterance(ch);
    const idx=parseInt($("#voice").value,10);
    if(Number.isFinite(idx) && voices[idx]) u.voice=voices[idx];
    u.rate=rate;
    speechSynthesis.speak(u);
    await new Promise(res=>{ u.onend=()=>setTimeout(res,140); u.onerror=()=>setTimeout(res,140); });
  }
}

const state = {
  mode:"challenge",
  variant:"standard",
  i:0,
  score:0,
  selected:null, // {type,id}
  slots:{ prefix:"none", base:"", suffix:"none" }
};

function pieceBy(type,id){
  const arr = (type==="prefix") ? PIECES.prefixes : PIECES.suffixes;
  return arr.find(p=>p.id===id) || arr[0];
}
function current(){ return CHALLENGES[state.i]; }

function setVariant(v){
  state.variant = (v==="supported") ? "supported" : "standard";
  document.body.classList.toggle("supported", state.variant==="supported");
  render();
}
function setMode(m){
  state.mode = (m==="free") ? "free" : "challenge";
  state.selected=null;
  if(state.mode==="challenge") load(0); else loadFree();
}
function selectPiece(type,id){
  state.selected={type,id};
  [...document.querySelectorAll(".piece")].forEach(b=>b.classList.toggle("sel", b.dataset.type===type && b.dataset.id===id));
  if(state.variant==="supported"){
    const p=pieceBy(type,id);
    speak(p.show.replace("-","").replace("(","").replace(")",""), 0.9);
  }
}
function place(slot){
  if(!state.selected) return;
  if(slot==="prefix" && state.selected.type!=="prefix") return;
  if(slot==="suffix" && state.selected.type!=="suffix") return;
  state.slots[slot]=state.selected.id;
  state.selected=null;
  [...document.querySelectorAll(".piece")].forEach(b=>b.classList.remove("sel"));
  renderAssembly();
}
function buildWord(){
  const c = (state.mode==="challenge") ? current() : { base: state.slots.base || "" };
  const base = c.base || "";
  const p = pieceBy("prefix", state.slots.prefix);
  const s = pieceBy("suffix", state.slots.suffix);
  const word = `${p.id==="none"?"":p.text}${base}${s.id==="none"?"":s.text}`.trim();
  const chunks = [
    p.id==="none" ? "" : p.show.replace("-",""),
    base,
    s.id==="none" ? "" : s.show.replace("-","")
  ].filter(Boolean);
  return { word, chunks };
}

function renderPieces(){
  const pre=$("#prefixPieces"), suf=$("#suffixPieces");
  pre.innerHTML=""; suf.innerHTML="";
  PIECES.prefixes.forEach(p=>{
    const b=document.createElement("button");
    b.className="piece"; b.type="button";
    b.dataset.type="prefix"; b.dataset.id=p.id;
    b.innerHTML=`${esc(p.show)} <span class="m">${esc(p.meaning)}</span>`;
    b.onclick=()=>selectPiece("prefix", p.id);
    pre.appendChild(b);
  });
  PIECES.suffixes.forEach(p=>{
    const b=document.createElement("button");
    b.className="piece"; b.type="button";
    b.dataset.type="suffix"; b.dataset.id=p.id;
    b.innerHTML=`${esc(p.show)} <span class="m">${esc(p.meaning)}</span>`;
    b.onclick=()=>selectPiece("suffix", p.id);
    suf.appendChild(b);
  });
}
function renderKey(){
  const rows = CHALLENGES.map((c,idx)=>{
    const parts = `${pieceBy("prefix",c.prefix).show} + ${c.base} + ${pieceBy("suffix",c.suffix).show}`;
    return `<tr><td>${idx+1}</td><td>${esc(c.prompt)}</td><td>${esc(parts)}</td><td><b>${esc(c.target)}</b></td><td>${esc(c.gloss||"")}</td></tr>`;
  }).join("");
  $("#key").innerHTML = `<table><thead><tr><th>#</th><th>Prompt</th><th>Parts</th><th>Target</th><th>Meaning</th></tr></thead><tbody>${rows}</tbody></table>`;
}
function renderAssembly(){
  const c = (state.mode==="challenge") ? current() : { base: state.slots.base || "play" };
  state.slots.base = c.base;
  const p=pieceBy("prefix", state.slots.prefix);
  const s=pieceBy("suffix", state.slots.suffix);

  $("#slotPrefix").innerHTML = (p.id==="none") ? `<span class="hint">${state.variant==="supported"?"No prefix":"Empty"}</span>`
    : `<span class="chip">${esc(p.show)} <span class="m">${esc(p.meaning)}</span></span>`;
  $("#slotBase").innerHTML = `<span class="chip" style="border-color:rgba(255,255,255,.16);background:rgba(255,255,255,.06)">${esc(c.base)}</span>`;
  $("#slotSuffix").innerHTML = (s.id==="none") ? `<span class="hint">${state.variant==="supported"?"No suffix":"Empty"}</span>`
    : `<span class="chip">${esc(s.show)} <span class="m">${esc(s.meaning)}</span></span>`;

  const built = buildWord();
  $("#builtWord").textContent = built.word || "—";
  $("#builtLine").innerHTML = (state.variant==="supported")
    ? `Chunks: <b>${built.chunks.map(esc).join("</b> + <b>")}</b>`
    : `Chunks: ${built.chunks.map(esc).join(" + ")}`;
}
function render(){
  $("#score").textContent = String(state.score);
  $("#total").textContent = String(CHALLENGES.length);
  if(state.mode==="free"){
    $("#titleBig").textContent="Free build";
    $("#taskHint").textContent="Experiment. Speak it. Decide: real word or silly word?";
    $("#showAnswer").disabled=true;
    $("#supportNote").style.display = (state.variant==="supported") ? "block" : "none";
    if(state.variant==="supported") $("#supportNote").innerHTML = "<b>Support cue:</b> Pick one piece that means “not/opposite” and listen to how it changes the word.";
  }else{
    const c=current();
    $("#titleBig").textContent=`Base word: ${c.base}`;
    $("#taskHint").textContent=c.prompt;
    $("#showAnswer").disabled=false;
    $("#supportNote").style.display = (state.variant==="supported") ? "block" : "none";
    if(state.variant==="supported"){
      const wantP=pieceBy("prefix",c.prefix), wantS=pieceBy("suffix",c.suffix);
      $("#supportNote").innerHTML = `<b>Support cue:</b> Prefix meaning: “${esc(wantP.meaning||"none")}” • Suffix meaning: “${esc(wantS.meaning||"none")}”`;
    }
  }
  renderAssembly();
}
function load(i){
  state.i = (i + CHALLENGES.length) % CHALLENGES.length;
  state.slots.prefix="none"; state.slots.suffix="none";
  $("#status").textContent="ready";
  render();
}
function loadFree(){
  state.slots.base="play";
  state.slots.prefix="none"; state.slots.suffix="none";
  $("#status").textContent="ready";
  render();
}
function next(){ if(state.mode==="challenge") load(state.i+1); else loadFree(); }
function showAnswer(){
  const c=current();
  state.slots.prefix=c.prefix; state.slots.suffix=c.suffix;
  $("#status").innerHTML = `<span class="warn">revealed</span> — <b>${esc(c.target)}</b>`;
  renderAssembly();
}
function check(){
  if(state.mode==="free"){
    const built=buildWord().word;
    const msg = built ? `You built: ${built}. Use it in a sentence (or explain why it’s weird).` : "Build something first.";
    $("#status").textContent=msg; speak(msg, state.variant==="supported"?0.86:0.95);
    return;
  }
  const c=current();
  const ok = (state.slots.prefix===c.prefix && state.slots.suffix===c.suffix);
  if(ok){
    $("#status").innerHTML = `<span class="ok">correct ✅</span> — <b>${esc(c.target)}</b> (${esc(c.gloss||"")})`;
    state.score++; render();
  }else{
    $("#status").innerHTML = `<span class="bad">not yet</span> — swap prefix/suffix and try again`;
  }
}

(function init(){
  renderPieces();
  renderKey();
  refreshVoices();
  if(window.speechSynthesis) speechSynthesis.onvoiceschanged = refreshVoices;

  $("#variant").onchange=(e)=>setVariant(e.target.value);
  $("#mode").onchange=(e)=>setMode(e.target.value);
  $("#slotPrefix").onclick=()=>place("prefix");
  $("#slotSuffix").onclick=()=>place("suffix");
  $("#nextTop").onclick=next;
  $("#clear").onclick=()=>{ state.slots.prefix="none"; state.slots.suffix="none"; $("#status").textContent="ready"; renderAssembly(); };
  $("#showAnswer").onclick=showAnswer;
  $("#check").onclick=check;
  $("#speakWord").onclick=()=>{ const w=buildWord().word; if(w) speak(w, state.variant==="supported"?0.86:0.95); };
  $("#speakChunks").onclick=()=>speakChunks(buildWord().chunks);

  load(0);
})();
</script>
<!-- WORDINESS_FAILSAFE_PATCH v1 -->
<script id="wordiness-failsafe-patch">
(function(){
  if (window.__wordinessFailsafePatch) return;
  window.__wordinessFailsafePatch = true;

  const VOWEL = /[aeiouy]/i;

  const EXCEPTIONS = {
    different:   { spelling:["dif","fer","ent"], spoken:[["dif","frent"],["dif","rent"]] },
    vegetable:   { spelling:["ve","ge","ta","ble"], spoken:[["veg","ta","ble"],["vej","ta","bul"]] },
    factory:     { spelling:["fac","to","ry"], spoken:[["fac","tuh","ree"],["fac","tri"]] },
    family:      { spelling:["fam","i","ly"], spoken:[["fam","ly"]] },
    chocolate:   { spelling:["choc","o","late"], spoken:[["choc","late"]] },
    camera:      { spelling:["cam","er","a"], spoken:[["cam","ra"]] },
    interesting: { spelling:["in","ter","est","ing"], spoken:[["in","tres","ting"]] },
    probably:    { spelling:["prob","a","bly"], spoken:[["prob","ly"]] }
  };

  function hasVowelLetters(s){ return VOWEL.test(String(s||"")); }
  function lettersSpaced(s){ return String(s||"").split("").join(" "); }
  function onlyLetters(s){ return String(s||"").toLowerCase().replace(/[^a-z']/g,""); }

  function normalizeLine(s){
    return String(s||"")
      .replace(/[\u2010\u2011\u2012\u2013\u2014\u2212]/g, "-") // fancy dashes
      .replace(/\u00B7/g, "·") // middle dot
      .trim();
  }

  // Extract sensible words from pasted text, but preserve already-marked syllable lines
  function sanitizeSeedText(raw){
    raw = String(raw||"").replace(/\r/g,"");
    const out = [];
    for (const line0 of raw.split("\n")) {
      const line = normalizeLine(line0);
      if (!line) continue;

      // Keep marked syllable lines like dif-fer-ent (no spaces)
      if (/[-·]/.test(line) && !/\s/.test(line)) {
        out.push(line);
        continue;
      }

      // Otherwise extract word tokens from the line
      const toks = line.match(/[A-Za-z]+(?:'[A-Za-z]+)?/g);
      if (!toks) continue;
      for (const w of toks) {
        if (w.length > 28) continue;
        if (!hasVowelLetters(w)) continue;
        out.push(w);
      }
    }

    // de-dupe, preserve order
    const seen = new Set();
    const final = [];
    for (const w of out) {
      const k = w.toLowerCase();
      if (seen.has(k)) continue;
      seen.add(k);
      final.push(w);
    }
    return final.join("\n");
  }

  // Replace a specific line (by index) with chunked form, joined by '-'
  function replaceLine(text, lineIndex, newChunks){
    const lines = String(text||"").replace(/\r/g,"").split("\n");
    if (lineIndex < 0 || lineIndex >= lines.length) return text;
    lines[lineIndex] = newChunks.join("-");
    return lines.join("\n");
  }

  // Find a textarea likely used for word lists
  function findSeedTextarea(){
    return document.querySelector("textarea#input, textarea#seed, textarea[data-seed], textarea");
  }

  // Build helper UI under textarea: reduction suggestions + failsafe warnings + sanitize button
  function attachHelperUI(ta){
    if (!ta || ta.__wordinessHelperAttached) return;
    ta.__wordinessHelperAttached = true;

    const host = document.createElement("div");
    host.style.cssText = [
      "margin-top:10px",
      "border:1px solid rgba(255,255,255,.14)",
      "border-radius:14px",
      "padding:10px 12px",
      "background:rgba(0,0,0,.10)",
      "color:rgba(238,242,255,.85)",
      "font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial",
      "font-size:13px"
    ].join(";");

    const hdr = document.createElement("div");
    hdr.style.cssText = "display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;";
    hdr.innerHTML = `<b>Wordiness helpers</b>
      <span style="opacity:.8">failsafes + disappearing-vowel options</span>`;
    host.appendChild(hdr);

    const btnRow = document.createElement("div");
    btnRow.style.cssText = "display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;";
    const sanitizeBtn = document.createElement("button");
    sanitizeBtn.type = "button";
    sanitizeBtn.textContent = "Sanitize pasted text → words";
    sanitizeBtn.style.cssText =
      "cursor:pointer;border-radius:999px;padding:8px 10px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.04);color:rgba(238,242,255,.92);font-weight:700;";
    btnRow.appendChild(sanitizeBtn);
    host.appendChild(btnRow);

    const msg = document.createElement("div");
    msg.style.cssText = "margin-top:10px;opacity:.9;";
    host.appendChild(msg);

    const sug = document.createElement("div");
    sug.style.cssText = "display:flex;gap:8px;flex-wrap:wrap;margin-top:10px;";
    host.appendChild(sug);

    function refresh(){
      const raw = String(ta.value||"");
      const lines = raw.replace(/\r/g,"").split("\n").map(normalizeLine);
      sug.innerHTML = "";

      // Warnings: chunks with no vowel letters (only checks marked chunk lines)
      let warnCount = 0;
      for (const ln of lines) {
        if (!ln) continue;
        if (/[-·]/.test(ln) && !/\s/.test(ln)) {
          const parts = ln.split(/[-·]+/).map(s=>s.trim()).filter(Boolean);
          const bad = parts.filter(p=>!hasVowelLetters(p));
          if (bad.length) warnCount++;
        }
      }

      // Suggestions for disappearing vowels
      const found = [];
      lines.forEach((ln, i)=>{
        if (!ln) return;
        const key = onlyLetters(ln.replace(/[-·]/g,""));
        if (EXCEPTIONS[key]) found.push({ key, i });
      });

      msg.innerHTML =
        `${warnCount ? `<span style="color:#f59e0b;font-weight:800">${warnCount} warning(s)</span> (chunk has no vowel letters). ` : `<span style="color:#22c55e;font-weight:800">No failsafe warnings</span>. `}
         ${found.length ? `Found <b>${found.length}</b> reduction word(s).` : `No reduction words detected in list.`}`;

      // Make buttons for each found word
      found.slice(0, 12).forEach(({key, i})=>{
        const ex = EXCEPTIONS[key];
        const label = key;
        const makeBtn = (text, chunks) => {
          const b = document.createElement("button");
          b.type = "button";
          b.textContent = `${label}: ${text}`;
          b.style.cssText =
            "cursor:pointer;border-radius:999px;padding:8px 10px;border:1px solid rgba(56,189,248,.28);background:rgba(56,189,248,.08);color:rgba(238,242,255,.92);font-weight:800;";
          b.onclick = ()=>{
            ta.value = replaceLine(ta.value, i, chunks);
            ta.dispatchEvent(new Event("input", { bubbles:true }));
          };
          return b;
        };

        if (ex.spelling) sug.appendChild(makeBtn("Use spelling", ex.spelling));
        if (Array.isArray(ex.spoken)) {
          ex.spoken.forEach(opt => sug.appendChild(makeBtn("Use spoken", opt)));
        }
      });
    }

    sanitizeBtn.onclick = ()=>{
      const before = ta.value;
      const after = sanitizeSeedText(before);
      if (after && after !== before) {
        ta.value = after;
        ta.dispatchEvent(new Event("input", { bubbles:true }));
      }
    };

    // Insert right after textarea
    ta.insertAdjacentElement("afterend", host);

    // Live update
    let t = null;
    ta.addEventListener("input", ()=>{
      clearTimeout(t);
      t = setTimeout(refresh, 120);
    });
    refresh();
  }

  // TTS fail-safe wrapper: if no vowel letters and short, speak letters spaced
  function wrapSpeak(fnName){
    const old = window[fnName];
    if (typeof old !== "function") return;
    if (old.__wordinessWrapped) return;

    function wrapped(text, ...rest){
      const t = String(text||"").trim();
      if (t && !hasVowelLetters(t) && t.length <= 8) {
        return old.call(this, lettersSpaced(t), ...rest);
      }
      return old.call(this, text, ...rest);
    }
    wrapped.__wordinessWrapped = true;
    window[fnName] = wrapped;
  }

  // Try common TTS function names used across your games
  ["speakNow","speak","speakText","say"].forEach(wrapSpeak);

  // Seed sanitiser if game uses #seed=
  function patchSeedFromHash(){
    const h = String(location.hash||"");
    if (!/seed=/.test(h)) return;
    const ta = findSeedTextarea();
    if (!ta) return;
    const before = ta.value;
    const after = sanitizeSeedText(before);
    if (after && after !== before) {
      ta.value = after;
      ta.dispatchEvent(new Event("input", { bubbles:true }));
    }
  }

  // Attach helpers on load
  function boot(){
    const ta = findSeedTextarea();
    if (ta) attachHelperUI(ta);
    patchSeedFromHash();
  }

  window.addEventListener("hashchange", ()=>setTimeout(patchSeedFromHash, 0));
  setTimeout(boot, 80);

})();
</script>
<!-- /WORDINESS_FAILSAFE_PATCH v1 -->
<script>
// wordiness-touch-helpers-v4
(function(){
  try{
    var isCoarse=false;
    try{ isCoarse = window.matchMedia && window.matchMedia("(pointer: coarse)").matches; }catch(e){}
    var isTouch = isCoarse || ("ontouchstart" in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints>0);

    // Crest fallback (works for /wordiness and file:// exports)
    var crest = document.getElementById("crest");
    if (crest && crest.tagName === "IMG") {
      crest.addEventListener("error", function(){ crest.src="/wordiness/crest.png"; }, { once:true });
    }

    if(!isTouch) return;

    var drags = Array.prototype.slice.call(document.querySelectorAll('[draggable="true"]'));
    if(!drags.length) return;

    drags.forEach(function(el){
      el.classList.add("wordiness-draggable");
      el.addEventListener("click", function(){
        drags.forEach(function(x){ x.classList.remove("wordiness-drag-selected"); });
        el.classList.add("wordiness-drag-selected");
      }, { passive:true });
    });

    var btn = document.createElement("button");
    btn.id="wordinessTouchToggle";
    btn.type="button";
    btn.style.position="fixed";
    btn.style.right="12px";
    btn.style.bottom="calc(12px + env(safe-area-inset-bottom, 0px))";
    btn.style.zIndex="9999";
    btn.style.border="1px solid rgba(255,255,255,.18)";
    btn.style.background="rgba(0,0,0,.45)";
    btn.style.color="rgba(238,242,255,.95)";
    btn.style.backdropFilter="blur(10px)";
    btn.style.borderRadius="999px";
    btn.style.padding="10px 12px";
    btn.style.font="600 13px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    btn.style.touchAction="manipulation";

    var dragEnabled=true;
    function applyState(){
      drags.forEach(function(el){ el.setAttribute("draggable", dragEnabled ? "true" : "false"); });
      btn.textContent = dragEnabled ? "Touch: Drag ON" : "Touch: Drag OFF";
    }
    btn.addEventListener("click", function(){ dragEnabled=!dragEnabled; applyState(); });

    document.body.appendChild(btn);
    applyState();
  }catch(e){}
})();
</script>
</body>
</html>
